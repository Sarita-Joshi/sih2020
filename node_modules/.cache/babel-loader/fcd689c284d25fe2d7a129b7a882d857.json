{"ast":null,"code":"var _ = require('underscore'),\n    request = require('request'),\n    querystring = require('querystring'),\n    async = require('async'),\n    entities = require('he'); // Globals\n\n\nvar apiBase = 'https://translation.googleapis.com/language/translate/v2/',\n    maxGetQueryLen = 4500,\n    maxSegments = 100,\n    concurrentLimit = 10; // Max num concurrent requests. Can be overridden by passing a new limit when requiring module\n////\n//  SEND REQUEST\n////\n// Closure that returns a function for making a\n// GET request to Google with an apiKey\n\nvar getRequestWithApi = function getRequestWithApi(apiKey) {\n  return function (path, data, done) {\n    var url = apiBase + path + '?' + querystring.stringify(_.extend({\n      'key': apiKey\n    }, data));\n    request.get(url, globalResponseHandler({\n      url: url\n    }, done));\n  };\n};\n\nvar postRequestWithApi = function postRequestWithApi(apiKey) {\n  return function (path, data, done) {\n    var requestData = {\n      url: apiBase + path,\n      method: 'POST',\n      form: querystring.stringify(_.extend({\n        'key': apiKey\n      }, data)),\n      headers: {\n        'X-HTTP-Method-Override': 'GET'\n      }\n    };\n    request(requestData, globalResponseHandler(requestData, done));\n  };\n}; ////\n//   RESPONSE HANDLERS\n////\n\n\nvar globalResponseHandler = function globalResponseHandler(request, done) {\n  return function (err, res, body) {\n    var msg;\n    if (!done || !_.isFunction(done)) return; // Catch connection errors\n\n    if (err || !res || res.statusCode !== 200) return done({\n      error: err,\n      response: res,\n      body: body,\n      request: request,\n      toString: function toString() {\n        return err ? err.toString() : '';\n      }\n    }, null); // Try to parse response\n\n    var parsedBody = null;\n\n    try {\n      parsedBody = JSON.parse(body);\n    } catch (e) {\n      err = 'Could not parse response from Google: ' + (body || 'null');\n      return done(err, null);\n    } // Return response\n\n\n    done(null, parsedBody);\n  };\n};\n\nvar parseTranslations = function parseTranslations(originalStrings, done) {\n  return function (err, data) {\n    if (err) return done(err, null); // Remove nesting\n\n    data = data.data;\n    data = data.translations ? data.translations : data; // Add originalText to response\n\n    originalStrings.forEach(function (s, i) {\n      if (data[i]) _.extend(data[i], {\n        originalText: s\n      });\n    }); // Decode html entities\n\n    data = data.map(function (translation) {\n      translation.translatedText = entities.decode(translation.translatedText);\n      return translation;\n    }); // Return nested languages array\n\n    done(null, data);\n  };\n};\n\nvar parseSupportedLanguages = function parseSupportedLanguages(done) {\n  return function (err, languages) {\n    if (err) return done(err, null);\n    languages = languages.data.languages;\n    if (languages[0] && !languages[0].name) languages = _.pluck(languages, 'language');\n    done(null, languages);\n  };\n};\n\nvar parseLanguageDetections = function parseLanguageDetections(originalStrings, done) {\n  return function (err, data) {\n    if (err) return done(err, null); // Remove nesting and parse\n\n    data = data.data && data.data.detections ? data.data.detections : data;\n\n    if (data.length > 1) {\n      data = data.map(function (d) {\n        return d[0];\n      });\n    } else {\n      data = data[0];\n    } // Add originalText to response\n\n\n    originalStrings.forEach(function (s, i) {\n      if (data[i]) _.extend(data[i], {\n        originalText: s\n      });\n    });\n    done(null, data);\n  };\n};\n\nvar shouldSplitSegments = function shouldSplitSegments(strings) {\n  if (!Array.isArray(strings)) return false; // Google allows a maximum of 128 segments\n\n  if (strings.length > maxSegments) return true; // Google allows max of 5k characters\n\n  return encodeURIComponent(strings.join(',')).length > maxGetQueryLen && strings.length !== 1;\n}; ////\n//  HELPERS\n////\n// Return array of arrays that are short enough for Google to handle\n\n\nvar splitArraysForGoogle = function splitArraysForGoogle(arr, result) {\n  if (arr.length > maxSegments || encodeURIComponent(arr.join(',')).length > maxGetQueryLen && arr.length !== 1) {\n    var mid = Math.floor(arr.length / 2);\n    splitArraysForGoogle(arr.slice(0, mid), result);\n    splitArraysForGoogle(arr.slice(mid, arr.length), result);\n  } else {\n    result.push(arr);\n  }\n}; ////\n//   PUBLIC API\n////\n\n\nmodule.exports = function (apiKey, options) {\n  options = options || {};\n  var requestOptions = options.requestOptions || {};\n\n  if (_.keys(requestOptions).length > 0) {\n    request = request.defaults(requestOptions);\n  } // Set new concurrent limit for async calls if specified\n\n\n  concurrentLimit = options.concurrentLimit || concurrentLimit;\n  var get = getRequestWithApi(apiKey),\n      post = postRequestWithApi(apiKey),\n      api = {}; // TRANSLATE\n\n  api.translate = function (strings, sourceLang, targetLang, done) {\n    // Make sourceLang optional\n    if (!done) {\n      done = targetLang;\n      targetLang = sourceLang;\n      sourceLang = null;\n    }\n\n    if (!_.isFunction(done)) return console.log('No callback defined');\n    if (typeof strings !== 'string' && !Array.isArray(strings)) return done('Input source must be a string or array of strings');\n    if (typeof targetLang !== 'string') return done('No target language specified. Must be a string'); // Split into multiple calls if string array is longer than allowed by Google (5k for POST)\n\n    var stringSets;\n\n    if (shouldSplitSegments(strings)) {\n      stringSets = [];\n      splitArraysForGoogle(strings, stringSets);\n    } else if (!Array.isArray(strings)) {\n      stringSets = [[strings]];\n    } else {\n      stringSets = [strings];\n    } // Request options\n\n\n    var data = {\n      target: targetLang\n    };\n    if (sourceLang) data.source = sourceLang; // Run queries async\n\n    async.mapLimit(stringSets, concurrentLimit, function (stringSet, done) {\n      post('', _.extend({\n        q: stringSet\n      }, data), parseTranslations(stringSet, done));\n    }, function (err, translations) {\n      if (err) return done(err); // Merge and return translation\n\n      translations = _.flatten(translations);\n      if (translations.length === 1) translations = translations[0];\n      done(null, translations);\n    });\n  }; // GET SUPPORTED LANGUAGES\n\n\n  api.getSupportedLanguages = function (target, done) {\n    // Data param is optional\n    if (_.isFunction(target)) {\n      done = target;\n      target = {};\n    } else {\n      target = {\n        target: target\n      };\n    }\n\n    if (!_.isFunction(done)) return console.log('No callback defined');\n    get('languages', target, parseSupportedLanguages(done));\n  }; // DETECT LANGUAGES\n\n\n  api.detectLanguage = function (strings, done) {\n    if (!done) return console.log('No callback defined');\n    if (typeof strings !== 'string' && !Array.isArray(strings)) return done('Input source must be a string or array of strings'); // Split into multiple calls if string array is longer than allowed by Google (5k for POST)\n\n    var stringSets;\n\n    if (shouldSplitSegments(strings)) {\n      stringSets = [];\n      splitArraysForGoogle(strings, stringSets);\n    } else if (!Array.isArray(strings)) {\n      stringSets = [[strings]];\n    } else {\n      stringSets = [strings];\n    } // Run queries async\n\n\n    async.mapLimit(stringSets, concurrentLimit, function (stringSet, done) {\n      post('detect', {\n        q: stringSet\n      }, parseLanguageDetections(stringSet, done));\n    }, function (err, detections) {\n      if (err) return done(err); // Merge arrays and return detections\n\n      detections = _.flatten(detections);\n      if (detections.length === 1) detections = detections[0];\n      done(null, detections);\n    });\n  }; ////\n  //   RETURN API\n  ////\n\n\n  return {\n    translate: api.translate,\n    getSupportedLanguages: api.getSupportedLanguages,\n    detectLanguage: api.detectLanguage\n  };\n};","map":{"version":3,"sources":["C:/Users/Sarita/react-firebase-authentication-starter-kit/node_modules/google-translate/lib/main.js"],"names":["_","require","request","querystring","async","entities","apiBase","maxGetQueryLen","maxSegments","concurrentLimit","getRequestWithApi","apiKey","path","data","done","url","stringify","extend","get","globalResponseHandler","postRequestWithApi","requestData","method","form","headers","err","res","body","msg","isFunction","statusCode","error","response","toString","parsedBody","JSON","parse","e","parseTranslations","originalStrings","translations","forEach","s","i","originalText","map","translation","translatedText","decode","parseSupportedLanguages","languages","name","pluck","parseLanguageDetections","detections","length","d","shouldSplitSegments","strings","Array","isArray","encodeURIComponent","join","splitArraysForGoogle","arr","result","mid","Math","floor","slice","push","module","exports","options","requestOptions","keys","defaults","post","api","translate","sourceLang","targetLang","console","log","stringSets","target","source","mapLimit","stringSet","q","flatten","getSupportedLanguages","detectLanguage"],"mappings":"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","sourcesContent":["var _               = require('underscore'),\n    request         = require('request'),\n    querystring     = require('querystring'),\n    async           = require('async'),\n    entities        = require('he');\n\n// Globals\nvar apiBase = 'https://translation.googleapis.com/language/translate/v2/',\n    maxGetQueryLen = 4500,\n    maxSegments = 100,\n    concurrentLimit = 10; // Max num concurrent requests. Can be overridden by passing a new limit when requiring module\n\n////\n//  SEND REQUEST\n////\n\n// Closure that returns a function for making a\n// GET request to Google with an apiKey\nvar getRequestWithApi = function(apiKey) {\n  return function(path, data, done) {\n    var url = apiBase + path + '?' + querystring.stringify(_.extend({ 'key': apiKey }, data));\n    request.get(url, globalResponseHandler({ url: url }, done));\n  };\n};\n\nvar postRequestWithApi = function(apiKey) {\n  return function(path, data, done) {\n    var requestData = {\n      url: apiBase + path,\n      method: 'POST',\n      form: querystring.stringify(_.extend({ 'key': apiKey }, data)),\n      headers: {\n        'X-HTTP-Method-Override': 'GET'\n      }\n    };\n    request(requestData, globalResponseHandler(requestData, done));\n  };\n};\n\n////\n//   RESPONSE HANDLERS\n////\n\nvar globalResponseHandler = function(request, done) {\n  return function(err, res, body) {\n    var msg;\n\n    if (!done || !_.isFunction(done)) return;\n\n    // Catch connection errors\n    if (err || !res || res.statusCode !== 200) return done({\n      error: err,\n      response: res,\n      body: body,\n      request: request,\n      toString: function() {\n        return err ? err.toString() : '';\n      },\n    }, null);\n\n    // Try to parse response\n    var parsedBody = null;\n    try {\n      parsedBody = JSON.parse(body);\n    } catch(e) {\n      err = 'Could not parse response from Google: ' + (body || 'null');\n      return done(err, null);\n    }\n\n    // Return response\n    done(null, parsedBody);\n  };\n};\n\nvar parseTranslations = function(originalStrings, done) {\n  return function(err, data) {\n    if (err) return done(err, null);\n\n    // Remove nesting\n    data = data.data;\n    data = data.translations ? data.translations : data;\n\n    // Add originalText to response\n    originalStrings.forEach(function(s, i){\n      if (data[i]) _.extend(data[i], { originalText: s });\n    });\n\n    // Decode html entities\n    data = data.map(function(translation){\n      translation.translatedText = entities.decode(translation.translatedText);\n      return translation;\n    });\n\n    // Return nested languages array\n    done(null, data);\n  };\n};\n\nvar parseSupportedLanguages = function(done) {\n  return function(err, languages) {\n    if (err) return done(err, null);\n    languages = languages.data.languages;\n    if (languages[0] && !languages[0].name) languages = _.pluck(languages, 'language');\n    done(null, languages);\n  };\n};\n\nvar parseLanguageDetections = function(originalStrings, done) {\n  return function(err, data) {\n    if (err) return done(err, null);\n\n    // Remove nesting and parse\n    data = data.data && data.data.detections ? data.data.detections : data;\n    if (data.length > 1) {\n      data = data.map(function(d){ return d[0]; });\n    } else {\n      data = data[0];\n    }\n\n    // Add originalText to response\n    originalStrings.forEach(function(s, i){\n      if (data[i]) _.extend(data[i], { originalText: s });\n    });\n\n    done(null, data);\n  };\n};\n\nvar shouldSplitSegments = function(strings) {\n  if (!Array.isArray(strings)) return false;\n\n  // Google allows a maximum of 128 segments\n  if (strings.length > maxSegments) return true;\n\n  // Google allows max of 5k characters\n  return encodeURIComponent(strings.join(',')).length > maxGetQueryLen && strings.length !== 1;\n};\n\n////\n//  HELPERS\n////\n\n// Return array of arrays that are short enough for Google to handle\nvar splitArraysForGoogle = function(arr, result) {\n  if (arr.length > maxSegments || (encodeURIComponent(arr.join(',')).length > maxGetQueryLen && arr.length !== 1)) {\n    var mid = Math.floor(arr.length / 2);\n    splitArraysForGoogle(arr.slice(0, mid), result);\n    splitArraysForGoogle(arr.slice(mid, arr.length), result);\n  } else {\n    result.push(arr);\n  }\n};\n\n////\n//   PUBLIC API\n////\n\nmodule.exports = function(apiKey, options) {\n  options = options || {}\n  var requestOptions = options.requestOptions || {}\n  if( _.keys( requestOptions ).length > 0 ) {\n    request = request.defaults( requestOptions );\n  }\n\n  // Set new concurrent limit for async calls if specified\n  concurrentLimit = options.concurrentLimit || concurrentLimit;\n\n  var get = getRequestWithApi(apiKey),\n      post = postRequestWithApi(apiKey),\n      api = {};\n\n\n  // TRANSLATE\n\n  api.translate = function(strings, sourceLang, targetLang, done) {\n    // Make sourceLang optional\n    if (!done) {\n      done = targetLang;\n      targetLang = sourceLang;\n      sourceLang = null;\n    }\n    \n    if (!_.isFunction(done)) return console.log('No callback defined');\n    if (typeof strings !== 'string' && !Array.isArray(strings)) return done('Input source must be a string or array of strings');\n    if (typeof targetLang !== 'string') return done('No target language specified. Must be a string');\n\n    // Split into multiple calls if string array is longer than allowed by Google (5k for POST)\n    var stringSets;\n    if (shouldSplitSegments(strings)) {\n      stringSets = [];\n      splitArraysForGoogle(strings, stringSets);\n    } else if (!Array.isArray(strings)) {\n      stringSets = [[strings]];\n    } else {\n      stringSets = [strings];\n    }\n\n    // Request options\n    var data = { target: targetLang };\n    if (sourceLang) data.source = sourceLang;\n\n    // Run queries async\n    async.mapLimit(stringSets, concurrentLimit, function(stringSet, done) {\n\n      post('', _.extend({ q: stringSet }, data), parseTranslations(stringSet, done));\n\n    }, function(err, translations) {\n      if (err) return done(err);\n\n      // Merge and return translation\n      translations = _.flatten(translations);\n      if (translations.length === 1) translations = translations[0];\n      done(null, translations);\n    });\n\n  };\n\n\n  // GET SUPPORTED LANGUAGES\n\n  api.getSupportedLanguages = function(target, done) {\n    // Data param is optional\n    if (_.isFunction(target)) {\n      done = target;\n      target = {};\n    } else {\n      target = { target: target };\n    }\n    if (!_.isFunction(done)) return console.log('No callback defined');\n\n    get('languages', target, parseSupportedLanguages(done));\n  };\n\n\n  // DETECT LANGUAGES\n\n  api.detectLanguage = function(strings, done) {\n    if (!done) return console.log('No callback defined');\n    if (typeof strings !== 'string' && !Array.isArray(strings)) return done('Input source must be a string or array of strings');\n\n    // Split into multiple calls if string array is longer than allowed by Google (5k for POST)\n    var stringSets;\n    if (shouldSplitSegments(strings)) {\n      stringSets = [];\n      splitArraysForGoogle(strings, stringSets);\n    } else if (!Array.isArray(strings)) {\n      stringSets = [[strings]];\n    } else {\n      stringSets = [strings];\n    }\n\n    // Run queries async\n    async.mapLimit(stringSets, concurrentLimit, function(stringSet, done) {\n\n      post('detect', { q: stringSet }, parseLanguageDetections(stringSet, done));\n\n    }, function(err, detections) {\n      if (err) return done(err);\n\n      // Merge arrays and return detections\n      detections = _.flatten(detections);\n      if (detections.length === 1) detections = detections[0];\n      done(null, detections);\n\n    });\n\n  };\n\n  ////\n  //   RETURN API\n  ////\n\n  return {\n    translate:                api.translate,\n    getSupportedLanguages:    api.getSupportedLanguages,\n    detectLanguage:           api.detectLanguage\n  };\n\n};\n"]},"metadata":{},"sourceType":"script"}